## 函数链接库

### 1 调用方式

1.  静态链接库
   静态链接在链接时会将函数库的代码拷贝到调用它的模块中。
   优点：
   - 运行速度快
   - 不需要使用者安装 .lib

   缺点：
   - 占用内存和磁盘空间。
   - 无法更新，部署。

2. 动态链接库
   动态链接允许在**载入时**或**运行时**确定 DLL 导出函数。核心是 LAZY 的思想，把链接过程推迟到运行时再进行。

   优点：
   - 耦合性小，独立性高，兼容性高。
   - 节省内存，节省磁盘空间

   缺点：
   
   - 运行时速度较慢，因为需要寻找GOT表格，还需要间接跳转，速度较慢。

### 2 动态链接库加载到内存地址的方式

动态连接库中有两种加载方案：

#### 2.1 静态共享库（地址固定）

静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在**某个特定的地址**划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为**静态**。

但是静态共享库的目标地址会导致地址冲突、升级等问题。

#### 2.2 动态共享库（地址不固定）

##### 2.2.1 装载时重定位技术

采用动态共享库的方式，也称为**装载时重定位（Load Time Relocation）**技术。其基本思路是：**在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。**

但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。

##### 2.2.2 **改进技术**：**地址无关代码**技术

- 基本原理：**代码和数据分离**，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。，改进了装载时重定位技术的缺点。

- 使用了动态共享库的程序的函数调用方式
  - **内部函数调用**：采用相对地址
  - **内部数据调用**：采用相对地址
  - **外部函数调用**：指令和地址分离，通过GOT表间接访问。
  - **外部数据调用**：指令和地址分离，通过GOT表间接访问。
##### 2.2.3 改进技术：**延迟绑定（PLT）**

由于动态链接下对于全局数据的访问和跨模块的调用都要进行复杂的GOT定位，导致**程序的运行速度减慢**大概1%~%5。又因为动态链接的链接工作在运行时完成，导致**程序的启动速度减慢**。
  对应于程序中的**重定位表`.rel.plt`**
  在Glibc中，动态链接器完成绑定工作的函数叫`_dl_runtime_resolve()`，它必须知道绑定发生在哪个模块中的哪个函数，因此假设其函数原型为`_dl_runtime_resolve(module, function)`。 当调用某个外部模块的函数时，并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转，每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项的地址称为bar@plt。来看看bar@plt的实现：

  ```bash
  bar@plt:
  jmp *(bar@GOT)
  push n
  push moduleID
  jump _dl_runtime_resolve
  ```

  bar@plt的第一条指令是通过GOT间接跳转的指令。bar@GOT表示GOT中保存bar()这个函数相应的项。如果链接器在初始化阶段已将bar()的地址填入该项，就跳转到bar()。但为了实现延迟绑定，链接器在初始化阶段并没有将bar()的地址填入到该项，而是将上面代码中第二条指令`push n`的地址填入到bar@GOT中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。第二条指令将一个数字n压入堆栈中，这个数字是bar这个符号引用在重定位表`.rel.plt`中的下标。接着又是一条push指令将模块的ID压入到堆栈，然后跳转到`_dl_runtime_resolve`。这实际上就是在实现`_dl_runtime_resolve`函数调用，它在进行一系列符号解析和重定位工作以后将bar()的真正地址填入到bar@GOT中。
  之后当我们再次调用bar@plt时，第一条jmp指令就能够跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里面保存的EIP直接返回到调用者，而不会再继续执行bar@plt中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。

### 3  动态链接库加载到内存地址的过程   todo

### 4 动态链接库动态链接库加载地址的确定   todo

要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。

**问题：**
意思是不是只要不打开 ASLR ，那么动态链接库的地址就一定是硬编码在函数中的，即使切换了环境，仍然是一个定值？
这个问题需要进一步了解动态链接库的机制。

### 5 重定位技术 todo


## 参考链接

- [计算机那些事(5)——链接、静态链接、动态链接](http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/)
- [鸟哥的私房菜 - 链接、装载与库 --- 动态链接](https://markrepo.github.io/kernel/2018/08/19/dynamic-link/)
- [GOT and PLT for pwning.](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html)
- [.plt .plt.got what is different?](https://stackoverflow.com/questions/58076539/plt-plt-got-what-is-different)

## 问题

- GOT 表是属于动态链接库的还是属于具体的单个程序的？
  目前观测的是每个程序都有

- 为什么不直接使用 GOT 表，还需要增加 PLT 表？
  我认为 GOT 表也可以独自完成  lazy binding 的任务。
- PLT 表 和 GOT 表，分别在哪个位置？
  在每个函数中都有，在每个程序中都有。
- 文件中的 ` .plt  .plt.got   .got  .got.plt  `的区别是什么呢？
  .plt ： use lazy binding
  .plt.got :  uses non-lazy binding.
  .got  ： 存储全局变量，如果开启 GOT保护，此部分只读。
  .got.plt：和 plt 一起使用，存储外部函数地址。运行时可写
- In the following examples, `objdump -d` is used for disassembly, and `readelf -r` is used to list relocations.
  意思就是编译选项有很多可用的组合，各种技术通过不同的编译选项是可选的，因此不要局限于某个程序一定会采用某种策略。